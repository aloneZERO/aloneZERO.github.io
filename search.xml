<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[神策数据电话面试]]></title>
      <url>/posts/a3744c3a/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-c098136b95b4a247.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stay Hungry, Stay Foolish."></p>
<a id="more"></a>
<h2 id="HashMap-底层原理"><a href="#HashMap-底层原理" class="headerlink" title="HashMap 底层原理"></a>HashMap 底层原理</h2><p><code>HashMap</code>是以键值对（key-value）的形式存储元素的。<code>HashMap</code>需要一个<strong>hash函数</strong>，它使用<code>hashCode()</code>和<code>equals()</code>方法向集合中添加元素或从集合中检索元素。</p>
<p>当调用<code>put()</code>方法的时候，<code>HashMap</code>会计算<code>key</code>的<code>hash</code>值，然后把键值对存储在集合中合适的索引上。如果<code>key</code>已经存在了，<code>value</code>会被更新成新值。</p>
<h2 id="HashMap-如何解决哈希冲突"><a href="#HashMap-如何解决哈希冲突" class="headerlink" title="HashMap 如何解决哈希冲突"></a>HashMap 如何解决哈希冲突</h2><p>使用<strong>拉链法</strong>。</p>
<p><code>HashMap</code>中哈希表的每一个元素其实是一个链表。当发生哈希冲突时，首先从该哈希索引对应的链表中查找是否已有相同<code>key</code>，若有则更新<code>value</code>即可，否则将使用链表的头插法，将冲突的新键值对插在链表的头部。</p>
<h2 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h2><p>两者都实现了<code>Map</code>接口，因此很多特性非常相似。但是，他们有以下不同点：</p>
<ul>
<li><code>HashMap</code>允许键和值是<code>null</code>，而<code>Hashtable</code>不允许键或者值是<code>null</code>。</li>
<li><code>HashMap</code>随着时间的推移，无法保证元素次序是不变的。</li>
<li><code>HashMap</code>提供了<code>fail-fast</code>迭代器，即多线程迭代会发生 <code>ConcurrentModificationException</code>。</li>
<li><code>Hashtable</code>是线程安全的，而<code>HashMap</code>不是。</li>
<li><code>Hashtable</code>提供了对键的枚举（Enumeration）。</li>
</ul>
<p>一般认为<code>Hashtable</code>是一个遗留的类。</p>
<h2 id="Hashtable-如何保证线程安全"><a href="#Hashtable-如何保证线程安全" class="headerlink" title="Hashtable 如何保证线程安全"></a>Hashtable 如何保证线程安全</h2><p>因为其每个可能引发线程安全的方法均被<code>synchronized</code>关键字修饰（加上了同步锁）。</p>
<h2 id="HashMap-如何变得线程安全"><a href="#HashMap-如何变得线程安全" class="headerlink" title="HashMap 如何变得线程安全"></a>HashMap 如何变得线程安全</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;Object, Object&gt; map = Collections.synchronizedMap(hashMap);</span><br></pre></td></tr></table></figure>
<h2 id="HashMap-和-LinkedHashMap-的区别"><a href="#HashMap-和-LinkedHashMap-的区别" class="headerlink" title="HashMap 和 LinkedHashMap 的区别"></a>HashMap 和 LinkedHashMap 的区别</h2><p>LinkedHashMap 继承自 HashMap，因此具有和其一样的快速查找的特性。</p>
<p>除此之外，LinkedHashMap 额外维护了一个双向链表，用来维护 Map 元素的插入顺序或者LRU（最近最久未使用）顺序。</p>
<h2 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a>数组和链表的区别</h2><ul>
<li>数组大小固定，链表则可以动态变化。</li>
<li>数组支持快速随机访问，链表只能通过遍历查找元素。</li>
<li>数组插入和删除元素时，涉及到大量元素的移动操作，性能差；而链表在找到插入位置或删除目标后，只需涉及到指针指向的变化，性能好。</li>
</ul>
<h2 id="手写算法题"><a href="#手写算法题" class="headerlink" title="手写算法题"></a>手写算法题</h2><p>题目一：基本字符串压缩</p>
<blockquote>
<p>利用字符重复出现的次数，编写一个方法，实现基本的字符串压缩功能。比如，字符串“aabcccccaaa”经压缩会变成“a2b1c5a3”。若压缩后的字符串没有变短，则返回原先的字符串。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">zipString</span><span class="params">(String iniString)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high, count;</span><br><span class="line">        <span class="keyword">int</span> len = iniString.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt; len) &#123;</span><br><span class="line">            high = low;</span><br><span class="line">            ch = iniString.charAt(low);</span><br><span class="line">            <span class="keyword">while</span> ((high &lt; len) &amp;&amp; (iniString.charAt(high) == ch)) &#123;</span><br><span class="line">                high++;</span><br><span class="line">            &#125;</span><br><span class="line">            count = high - low;</span><br><span class="line">            sb.append(ch);</span><br><span class="line">            sb.append(count);</span><br><span class="line">            low = high;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sb.toString().length() &lt; len) ? sb.toString() : iniString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目二：实现简单哈希表以及查找功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List[] base = <span class="keyword">new</span> List[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base.length; i++) &#123;</span><br><span class="line">            base[i] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String elem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elem == <span class="keyword">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> elem.hashCode() % <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(str);</span><br><span class="line">        <span class="keyword">if</span> (hash == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't add null!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        base[hash].add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = hash(str);</span><br><span class="line">        List&lt;String&gt; temp = base[hash];</span><br><span class="line">        <span class="keyword">for</span> (String s : temp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.equals(str)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10亿整数，1G内存，快速去重"><a href="#10亿整数，1G内存，快速去重" class="headerlink" title="10亿整数，1G内存，快速去重"></a>10亿整数，1G内存，快速去重</h2><p>参考博文：<a href="https://blog.csdn.net/hustwht/article/details/52181643" target="_blank" rel="noopener">https://blog.csdn.net/hustwht/article/details/52181643</a></p>
<h2 id="什么是虚拟内存（操作系统）"><a href="#什么是虚拟内存（操作系统）" class="headerlink" title="什么是虚拟内存（操作系统）"></a>什么是虚拟内存（操作系统）</h2><p>让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<h2 id="虚拟内存的最大容量由什么决定"><a href="#虚拟内存的最大容量由什么决定" class="headerlink" title="虚拟内存的最大容量由什么决定"></a>虚拟内存的最大容量由什么决定</h2><p>由计算机的地址结构决定，即 CPU 的位数。64位系统环境下，虚拟内存技术使得进程可用内存空间达<strong>2的64次幂字节</strong>，显然这只是理论数值。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p>
<ul>
<li><p><strong>地址空间和其它资源</strong>：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</p>
</li>
<li><p><strong>通信</strong>：进程间通信（<a href="https://baike.baidu.com/item/ipc/19486140?fr=aladdin" target="_blank" rel="noopener">IPC技术</a>），线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</p>
</li>
<li><p><strong>调度和切换</strong>：线程上下文切换比进程上下文切换要快得多。</p>
</li>
<li><p>在多线程操作系统中，进程不是一个可执行的实体。</p>
</li>
</ul>
<h2 id="网络-ARP-协议的作用"><a href="#网络-ARP-协议的作用" class="headerlink" title="网络 ARP 协议的作用"></a>网络 ARP 协议的作用</h2><p>ARP 是地址解析协议，解决 IP 地址到硬件 MAC 地址的映射问题。</p>
<h2 id="说几个熟悉的-HTTP-状态码"><a href="#说几个熟悉的-HTTP-状态码" class="headerlink" title="说几个熟悉的 HTTP 状态码"></a>说几个熟悉的 HTTP 状态码</h2><p>2xx 成功</p>
<ul>
<li>200 OK：一切正常</li>
</ul>
<p>3xx 重定向</p>
<ul>
<li>301 Moved Permanently：客户请求的文档在其他地方</li>
</ul>
<p>4xx 客户机中出现的错误</p>
<ul>
<li>400 Bad Request：请求出现语法错误</li>
<li>401 Unauthorized：客户视图未经授权访问受密码保护的页面</li>
<li>403 Forbiden：资源不可用。请求被拒绝</li>
<li>404 Not Found：无法找到指定位置的资源</li>
</ul>
<p>5xx 服务器中出现的错误</p>
<ul>
<li>500 Inernal Server Error：服务器遇到意料不到的情况，不能完成客户请求</li>
<li>501 Not Implemented：服务器不支持实现请求所需要的功能</li>
<li>502 Bad Gateway：服务器作为网关或代理，为了完成请求访问下一个服务器，该服务器返回了非法的应答</li>
<li>503 Service Unavailable：服务器由于维护或负载过重未能应答</li>
<li>504 Gateway Timeout：服务器作为网关或代理，不能及时从远程服务器获得应答</li>
<li>505 HTTP Version Not Supported：服务器不支持请求中所指明的 HTTP 版本（HTTP 1.1新）</li>
</ul>
<h2 id="Linux-查看进程端口"><a href="#Linux-查看进程端口" class="headerlink" title="Linux 查看进程端口"></a>Linux 查看进程端口</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先查找进程的 PID</span></span><br><span class="line">ps -ef | grep thread_name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看进程端口</span></span><br><span class="line">netstat -anp | grep PID</span><br></pre></td></tr></table></figure>
<h2 id="Linux-kill-9-和-kill-15-的区别"><a href="#Linux-kill-9-和-kill-15-的区别" class="headerlink" title="Linux kill -9 和 kill -15 的区别"></a>Linux kill -9 和 kill -15 的区别</h2><p><code>kill</code>的参数其实是信号编号。</p>
<p><strong>SIGKILL(9)</strong>：立即杀死进程。该信号不能被阻塞，处理和忽略。不推荐~</p>
<p><strong>SIGTERM(15)</strong>：正常退出进程，退出前可以被阻塞或回调处理。并且它是 Linux 缺省的程序中断信号。推荐使用！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看全部的信号编号</span></span><br><span class="line">kill -l</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 那年编程那些事儿 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 神策数据 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CVTE 电话面试]]></title>
      <url>/posts/9e4eea06/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-69f5b3738ec6eaa6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stay Hungry, Stay Foolish."></p>
<a id="more"></a>
<h2 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h2><ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<h2 id="多态有什么好处"><a href="#多态有什么好处" class="headerlink" title="多态有什么好处"></a>多态有什么好处</h2><p><strong>什么是多态？</strong></p>
<p>同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说：就是用基类的引用指向子类的对象。</p>
<p><strong>为什么要用多态？</strong></p>
<p>封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——<strong>代码重用</strong>。而多态除了代码的复用性外，还可以解决项目中紧偶合的问题，提高程序的可扩展性。耦合度讲的是模块与模块之间，代码与代码之间的关联度，通过对系统的分析把他分解成一个一个子模块，子模块提供稳定的接口，达到降低系统耦合度的目的，模块与模块之间尽量使用模块接口访问，而不是随意引用其他模块的成员变量。</p>
<p><strong>多态的好处</strong></p>
<ol>
<li>应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。// 继承 </li>
<li>派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 // 多态的真正作用</li>
</ol>
<h2 id="实现多态的方式"><a href="#实现多态的方式" class="headerlink" title="实现多态的方式"></a>实现多态的方式</h2><ol>
<li>实现接口</li>
<li>继承父类，重写父类方法；或继承的是抽象类，实现抽象方法</li>
<li>同一个类中，方法重载</li>
</ol>
<h2 id="创建对象实例的方式有哪些？"><a href="#创建对象实例的方式有哪些？" class="headerlink" title="创建对象实例的方式有哪些？"></a>创建对象实例的方式有哪些？</h2><ol>
<li><p>使用<code>new</code>关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用反射机制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">User user = (User) Class.forName(<span class="string">"package.User"</span>).newInstance();</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">User user = User.class.newInstance();</span><br><span class="line"><span class="comment">// 调用构造方法</span></span><br><span class="line">Constructor&lt;User&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = constructor.newInstance();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>clone</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// clone 被 protected 修饰</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CloneTest cloneTest = <span class="keyword">new</span> CloneTest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CloneTest copy = (CloneTest) cloneTest.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initializes The Object</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"Leo"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write Obj to File（序列化）</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>))) &#123;</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read Obj from File（反序列化）</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(file))) &#123;</span><br><span class="line">            User newUser = (User) ois.readObject();</span><br><span class="line">            System.out.println(newUser);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!file.delete()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"无法删除该文件："</span> + file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1565116950906132146L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    User(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="double-和-BigDecimal-比较"><a href="#double-和-BigDecimal-比较" class="headerlink" title="double 和 BigDecimal 比较"></a>double 和 BigDecimal 比较</h2><p><code>BigDecimal</code>的缺点：</p>
<ol>
<li>占用更多内存；</li>
<li>与基本类型相比，不能使用数学运算符，计算方式更复杂；</li>
<li>执行效率慢。</li>
</ol>
<p><code>BigDecimal</code>的优点：</p>
<ol>
<li>精度更高，避免出现<code>double</code>运算精度异常的问题；</li>
<li>更灵活和方便的小数点处理（支持多种舍入模式）。</li>
</ol>
<h2 id="IO-和-NIO-比较"><a href="#IO-和-NIO-比较" class="headerlink" title="IO 和 NIO 比较"></a>IO 和 NIO 比较</h2><table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向流</td>
<td>面向缓冲区、基于通道</td>
</tr>
<tr>
<td>阻塞 IO</td>
<td>非阻塞 IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器（Selectors）</td>
</tr>
</tbody>
</table>
<h2 id="Hashtable-和-HashMap-比较"><a href="#Hashtable-和-HashMap-比较" class="headerlink" title="Hashtable 和 HashMap 比较"></a>Hashtable 和 HashMap 比较</h2><ol>
<li><code>HashMap</code>可以插入<code>key</code>或<code>value</code>为<code>null</code> 的 <code>Entry</code> ；</li>
<li><code>HashMap</code> 把<code>Hashtable</code>的 <code>contains</code>方法移除了，改成<code>containsValue</code>和<code>containsKey</code>。因为 <code>contains</code> 方法容易让人引起误解；</li>
<li><code>HashTable</code> 的迭代器是<code>fail-fast</code>迭代器；</li>
<li><code>HashMap</code>不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
<li><code>HashTable</code> 的方法均使用 <code>synchronized</code> 修饰。</li>
</ol>
<h2 id="HashMap-的扩容策略"><a href="#HashMap-的扩容策略" class="headerlink" title="HashMap 的扩容策略"></a>HashMap 的扩容策略</h2><p>三个关键参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>capacity</td>
<td>table 容量大小，默认为 16。且必须保证该值为 2 的 n 次方</td>
</tr>
<tr>
<td>size</td>
<td>键值对的数量</td>
</tr>
<tr>
<td>threshold</td>
<td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作</td>
</tr>
<tr>
<td>loadFactor</td>
<td>装载因子，table 能够使用的比例，threshold=capacity*loadFactor</td>
</tr>
</tbody>
</table>
<p>当需要扩容时，<code>capacity</code>将变为原来的两倍。</p>
<h2 id="介绍下红黑树"><a href="#介绍下红黑树" class="headerlink" title="介绍下红黑树"></a>介绍下红黑树</h2><p>红黑树是一种自平衡二叉查找树。它可以在<code>O(log n)</code>时间内完成查找、插入和删除，这里 n 是树中元素的数目。</p>
<p>红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。</p>
<p>红黑树还不了解，待补充……</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p><strong>四种元注解</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Target</td>
<td>描述注解的作用目标</td>
</tr>
<tr>
<td>@Retention</td>
<td>需要在什么级别保存该注解信息，用于描述注解的生命周期</td>
</tr>
<tr>
<td>@Documented</td>
<td>表明注解包含在 Javadoc 生成的文档中</td>
</tr>
<tr>
<td>@Inherited</td>
<td>表明注解可以被继承</td>
</tr>
</tbody>
</table>
<p><code>@Target</code>的作用目标包括：</p>
<ul>
<li><code>ElementType.TYPE</code>：接口、类、枚举、注解</li>
<li><code>ElementType.FIELD</code>：字段、枚举的常量</li>
<li><code>ElementType.METHOD</code>：方法</li>
<li><code>ElementType.PARAMETER</code>：方法参数</li>
<li><code>ElementType.CONSTRUCTOR</code>：构造函数</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：局部变量</li>
<li><code>ElementType.ANNOTATION_TYPE</code>：注解</li>
<li><code>ElementType.PACKAGE</code>：包</li>
</ul>
<p><code>@Retention</code>注解的保留策略包括：</p>
<ul>
<li><p><code>RetentionPolicy.SOURCE</code>：仅存在于源码中，在字节码文件中不包含</p>
</li>
<li><p><code>RetentionPolicy.CLASS</code>：默认。会在字节码文件中存在，但运行时无法获得</p>
</li>
<li><code>RetentionPolicy.RUNTIME</code>：会在字节码文件中存在，运行时可通过反射获取到</li>
</ul>
<p><strong>自定义注解示例模板</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@元注解</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">	修饰符 返回值 属性名() <span class="keyword">default</span> + something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义注解的解析</strong>：自己选取一个合适的时机和位置，比如工厂类创建对象实例的方法中，根据反射技术，拿到用户想要创建的对象上的注解，然后根据注解去做相应的初始化工作。再比如校验性注解，在一个校验方法中，传入对象实例，根据反射拿到注解注明的校验信息，然后判断该实例是否合法。</p>
<h2 id="介绍几种常用的设计模式"><a href="#介绍几种常用的设计模式" class="headerlink" title="介绍几种常用的设计模式"></a>介绍几种常用的设计模式</h2><p>单例：确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<p>简单工厂：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。</p>
<p>观察者：定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。</p>
<p>代理：控制对其它对象的访问。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol>
<li>自己项目的一些问题；</li>
<li>谈谈职业规划；</li>
<li>平常如何学习技术；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 那年编程那些事儿 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> CVTE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC 大文件上传之连接重置]]></title>
      <url>/posts/efbbbff4/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-34816aa8af8b525f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>文件上传功能，想必大家都实现过，但最近自己却踩到一个不怎么被人注意的坑：<a href="#">上传文件过大导致浏览器出现 <strong>ERR_CONNECTION_RESET</strong></a></p>
</blockquote>
<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回想一下 Spring MVC 配置文件上传的过程：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"your.controller"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在该类中配置文件上传解析器的 Bean 交给 Spring 管理即可</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonsMultipartResolver <span class="title">multipartResolver</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        CommonsMultipartResolver  resolver = <span class="keyword">new</span> CommonsMultipartResolver();</span><br><span class="line">        resolver.setDefaultEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        resolver.setUploadTempDir(</span><br><span class="line">                <span class="keyword">new</span> FileSystemResource(uploadTempDir));</span><br><span class="line">        resolver.setMaxInMemorySize(<span class="number">0</span>); </span><br><span class="line">        resolver.setMaxUploadSizePerFile(<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024L</span>); </span><br><span class="line">        resolver.setMaxUploadSize(<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024L</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>问题就出在这两个参数的设置上：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resolver.setMaxUploadSizePerFile(<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024L</span>); </span><br><span class="line">resolver.setMaxUploadSize(<span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024L</span>);</span><br></pre></td></tr></table></figure></p>
<p>第一行，我们把上传中单个文件的最大值限制为 <strong>5MB</strong>；<br>第二行，我们把上传数据总大小的最大值限制为 <strong>10MB</strong>。<br>即如下情况均是过大：</p>
<ul>
<li>5MB + 5MB + 1MB （上传3个文件，总量过大）</li>
<li>6MB + 4MB（上传2个文件，单文件过大）</li>
</ul>
<hr>
<p>我们理想的处理逻辑思路有两种：</p>
<ol>
<li>当上传数据超过这里的限制时会抛出相应的异常，这时我们使用 Spring MVC 的异常处理机制对异常进行处理并跳转到错误提示页面。</li>
<li>使用拦截器拦截上传请求，发现上传数据过大后，做进一步的处理。</li>
</ol>
<p>但是……<strong>实际效果却是大相径庭！</strong></p>
<hr>
<p>只要上传数据大小超过这两个参数的任何一个，浏览器就会出现 <strong>ERR_CONNECTION_RESET</strong>，表示连接已被重置。一开始我认为是拦截器没有起作用，但经过多次测试，才发现只要上传数据过大，服务器程序（Tomcat、Jetty etc.）直接断开连接，请求根本到不了拦截器，连处理异常的机会都不给你。这次是<strong>服务器程序</strong>要背锅了。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然如此，那就<strong>来者不拒！</strong>我们把这两个参数设置的尽可能大，把处理逻辑交给拦截器和异常处理器，或者使用参考链接里给出的方案——配置相应服务器程序的属性，如 Tomcat 则需要配置 Connector 中的 <code>maxSwallowSize</code> ，默认只有 2MB。详情请阅读：<a href="http://tomcat.apache.org/tomcat-8.0-doc/config/http.html" target="_blank" rel="noopener">Tomcat 8 - HTTP Connector</a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resolver.setMaxUploadSizePerFile(<span class="number">666</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024L</span>); <span class="comment">// 666GB</span></span><br><span class="line">resolver.setMaxUploadSize(<span class="number">666</span>*<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024L</span>); <span class="comment">// 666GB</span></span><br></pre></td></tr></table></figure></p>
<p>拦截器<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:app.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 SpEL 表达式解析，避免类型转换异常</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;T(Long).parseLong('$&#123;upload.maxsize&#125;')&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ServletFileUpload.isMultipartContent(request)) &#123;</span><br><span class="line">            ServletRequestContext requestContext = <span class="keyword">new</span> ServletRequestContext(request);</span><br><span class="line">            <span class="keyword">long</span> requestSize = requestContext.contentLength();</span><br><span class="line">            log.info(<span class="string">"上传数据大小：&#123;&#125;MB"</span>, requestSize/<span class="number">1024</span>/<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">if</span> (requestSize &gt; maxSize) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MaxUploadSizeExceededException(maxSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>异常处理<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MaxUploadSizeExceededException.class)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleUploadOverSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            MaxUploadSizeExceededException e,</span></span></span><br><span class="line"><span class="function"><span class="params">            Model model)</span> </span>&#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        model.addAttribute(<span class="string">"message"</span>, <span class="string">"上传失败！文件太大了！！！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>tips</strong>: 大家也许注意到代码里 <code>log</code> 实例根本没有被创建就直接使用了？这是 <a href="https://projectlombok.org/" target="_blank" rel="noopener">Lombok</a> 中 <code>@slf4j</code> 注解的功劳。这是一个代码简化工具包，十分推荐大家了解并使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://stackoverflow.com/questions/29113262/could-not-upload-large-file-to-server-by-using-spring-mvc" target="_blank" rel="noopener">Could not upload large file to server by using Spring MVC</a></p>
]]></content>
      
        <categories>
            
            <category> Spring MVC </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring MVC </tag>
            
            <tag> Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 命令操作从观望到上手]]></title>
      <url>/posts/cc0f686d/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1606489-1150648dc9aa8301.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自网络"></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p><em>写给所有的 Linux 小白和我。</em></p>
</blockquote>
<p><strong>tips:</strong> 如果哪个命令不会用，直接 <code>command --help</code> 召唤帮助列表就完事了。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>查看目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls        <span class="comment"># 目录内容</span></span><br><span class="line">ls path   <span class="comment"># 显示指定路径目录下的内容</span></span><br><span class="line">ls -a     <span class="comment"># 显示目录全部内容，包括隐藏文件（a 即 all 的意思）</span></span><br><span class="line">ls -al    <span class="comment"># 在显示全部的基础上，以列表的形式显示</span></span><br><span class="line">ls -R     <span class="comment"># 递归显示目录内容</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1606489-e1e71751dd28bce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ls 命令演示"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls -li 显示的信息解释</span></span><br><span class="line"></span><br><span class="line">inode | 文件类型和权限 | 链接数 | 所属用户 | 所属用户组 | 文件大小 | 最后访问或修改时间 | 文件名</span><br><span class="line">20039 drwxrwxr-x 2 hadoop hadoop 4096 11月 28 00:26 tmp</span><br><span class="line">20040 -rw-rw-r-- 1 hadoop hadoop  144 11月 28 00:29 tmp.txt</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>inode</td>
<td>文件信息索引编号（目录是特殊的文件）</td>
</tr>
<tr>
<td>文件类型</td>
<td><code>-</code>代表普通文件、<code>d</code>代表目录、<code>l</code>代表链接（例 <code>java -&gt; /jdk7/bin/java</code>，访问 <code>java</code> 实际是访问链接的地址）即快捷方式</td>
</tr>
<tr>
<td>文件权限</td>
<td><code>rw-rw-r--</code> 依次代表 所属用户可读，可写，不可执行，所属用户组可读，可写，不可执行，其他用户可读，不可写，不可执行（<code>x</code>表示可执行）</td>
</tr>
<tr>
<td>链接数</td>
<td>数值为 1 代表自身（目前不懂还这个概念）</td>
</tr>
<tr>
<td>文件所属用户</td>
<td>文件归谁所有，例如上述的 tmp.txt 文件就是归于用户 hadoop（root 用户就会显示 root）</td>
</tr>
<tr>
<td>文件所属用户组</td>
<td>同样的道理，tmp.txt 文件归于用户组 hadoop</td>
</tr>
<tr>
<td>文件大小</td>
<td>tmp.txt 文件大小 144 byte。<code>-h</code>参数增强可读性 tmp 文件大小 4096 byte 会显示为 4.0k</td>
</tr>
<tr>
<td>访问或修改时间</td>
<td>指的是最后的一次访问或修改</td>
</tr>
</tbody>
</table>
<p>打印路径<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pwd</span>    <span class="comment"># 显示当前所在目录的绝对路径</span></span><br><span class="line"><span class="built_in">pwd</span> -P <span class="comment"># 目录连接链接时,显示出实际路径,而非使用链接（link）路径</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1606489-b2ff8dc6d1f0a751.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pwd 命令演示"></p>
<p>创建目录<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir dir          <span class="comment"># 在当前路径下创建一个目录</span></span><br><span class="line">mkdir -p dir1/dir2 <span class="comment"># 一次性创建多级目录</span></span><br></pre></td></tr></table></figure></p>
<p>删除文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm file        <span class="comment"># 删除文件</span></span><br><span class="line">rm -r dir      <span class="comment"># 删除目录</span></span><br><span class="line">rm -rf dir     <span class="comment"># 强制删除目录及目录下的所有内容且忽略提示</span></span><br><span class="line">sudo rm -rf /* <span class="comment"># 自杀式毁灭打击！</span></span><br></pre></td></tr></table></figure></p>
<p>拷贝文件<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp file1 file2  <span class="comment"># 复制文件1为文件2</span></span><br><span class="line">cp -r dir1 dir2 <span class="comment"># 复制目录1为目录2；如果目录2不存在，自动创建</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1606489-e4f10ff5dd5710ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cp 命令演示"></p>
<p>重命名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 重命名文件或目录</span><br><span class="line"># 若 file2 是目录，则移动 file1 到 file2 下</span><br><span class="line">mv file1 file2 </span><br><span class="line"># 其实它是移动文件或目录，重命名是特殊情况下的特殊效果</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1606489-f6b0a6c2ea591f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="mv 命令演示"></p>
<p>创建文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch filename.suffix  # 创建一个空文件（指定文件名和文件后缀名）</span><br><span class="line">cat &gt; file             # 键盘输入内容到文件（覆写文件内容），Ctrl + C 终止输入</span><br><span class="line">cat &gt;&gt; file            # 追加文件内容</span><br><span class="line">cat file1 &gt;&gt; file2     # file1 内容追加到 file2</span><br><span class="line">cat file               # 一次性打印文件全部内容</span><br><span class="line">more file              # 打印文件内容，Enter 键翻页</span><br></pre></td></tr></table></figure></p>
<p>更详细的重定向介绍：<a href="http://www.cnblogs.com/lovemo1314/archive/2011/07/13/2105472.html" target="_blank" rel="noopener">Linux 重定向命令</a></p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>查看进程<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps 一般和 grep 结合使用，查看某个进程的信息</span></span><br><span class="line">ps -ef             <span class="comment"># 显示当前的活动进程</span></span><br><span class="line">ps                 <span class="comment"># 仅仅使用 ps ，只会显示 ps 和 bash（shell 进程）</span></span><br><span class="line">ps -el             <span class="comment"># -l: long format, 显示更多进程信息</span></span><br><span class="line">ps -ef | grep 3306 <span class="comment"># 显示含有 3306 的进程信息</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1606489-bf73498118d71d25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ps -e | grep 用法演示"></p>
<p>任务管理器<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top             <span class="comment"># 动态显示当前所有的运行中进程（命令行版的进程管理器）</span></span><br><span class="line">top -u username <span class="comment"># 仅显示某个用户的进程</span></span><br></pre></td></tr></table></figure></p>
<p>停止进程<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一般套路: 通过 ps or nestat | grep 结合使用确定目标进程或服务的 PID，然后 kill 掉。</span></span><br><span class="line"><span class="comment"># 如果有些进程存在子进程，直接 kill -9 的话，强制进程在运行时突然终止，进程在结束后不能自我清理。</span></span><br><span class="line"><span class="comment"># 会导致系统资源无法正常释放，不推荐使用，除非其他办法都无效。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> pid          <span class="comment"># 根据进程的 pid, 杀掉进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 pid       <span class="comment"># 根据进程 pid, 强制终止进程</span></span><br><span class="line">killall proc_name <span class="comment"># 杀掉所有进程名含有 ‘proc_name’ 的进程</span></span><br></pre></td></tr></table></figure></p>
<p>更多进程管理细节，移步这里：<a href="http://www.cnblogs.com/act123/archive/2011/08/22/2148819.html" target="_blank" rel="noopener">Linux 查看进程和终止进程的技巧</a></p>
<p>后台运行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关于 bg 和 fg 命令</span></span><br><span class="line"><span class="comment"># 情景: 如果运行的一个程序需要很长的时间，但你又想干其他的事~</span></span><br><span class="line"><span class="comment"># 这时就可以 Ctrl+Z, 挂起这个程序（把前台执行的程序放到后台，并且暂停它）</span></span><br><span class="line"><span class="comment"># 根据对应的 job 作业号在后台启动它</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>          <span class="comment"># 显示当前所有后台运行的程序</span></span><br><span class="line"><span class="built_in">bg</span> job_number <span class="comment"># 后台启动一个暂停的程序</span></span><br><span class="line"><span class="built_in">fg</span> job_number <span class="comment"># 将后台运行的程序切换到前台继续运行</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1606489-5db99d99863b0c24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="bg and fg 命令演示"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 另一个常用的做法，在执行的命令后加上 &amp;</span></span><br><span class="line"><span class="built_in">command</span> &amp;       <span class="comment"># 后台运行，关掉终端会停止运行</span></span><br><span class="line">nohup <span class="built_in">command</span> &amp; <span class="comment"># 后台运行，关掉终端也会继续运行</span></span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1606489-907b126e8f499a9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="command &amp; 演示"></p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><code>locate</code> 命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自身体会，查找真是太常用了！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先说 locate 命令</span></span><br><span class="line"><span class="comment"># 默认模糊查询,列出查询结果的绝对路径，所以找的是文件还是目录是无所谓的</span></span><br><span class="line"><span class="comment"># 该命令有一个自己的索引库，无参数使用就是从库里搜索结果并列出</span></span><br><span class="line"><span class="comment"># 类似 Win 下的软件：everything，不过 everything 每次启动都会刷新索引库</span></span><br><span class="line"><span class="comment"># 索引库并非实时更新，所以无参数总会搜出已经不存在的文件</span></span><br><span class="line"><span class="comment"># 参数 -e 代表仅列出当前系统中存在的结果，所以我通常都会加上</span></span><br><span class="line"></span><br><span class="line">locate -e filename</span><br><span class="line">sudo updatedb      <span class="comment"># 手动更新索引库。默认一天一更新</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1606489-2382b8f505332d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="locate 命令演示"></p>
<p><code>find</code> 命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于 locate 索引库非实时的缘故</span></span><br><span class="line"><span class="comment"># 使用 find 命令就会搜的更准确</span></span><br><span class="line"></span><br><span class="line">sudo find start_path -name file_name</span><br><span class="line"><span class="comment"># start_path 通常指定为 '/' 根目录，这样就是全盘查找</span></span><br><span class="line"><span class="comment"># 指定根目录后需要足够的权限，所以加上 sudo 或 root 用户执行</span></span><br><span class="line"><span class="comment"># 精确查找，匹配完整文件名</span></span><br><span class="line"><span class="comment"># find 非常强大，更多玩法建议去搜下专门讲 find 的博客</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1606489-8fd17d244111676c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="find 命令演示"></p>
<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p>CPU<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 CPU 型号</span></span><br><span class="line">cat /proc/cpuinfo | grep name | cut -d: -f2 | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看物理 CPU 个数</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">"physical id"</span> | sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个物理 CPU 中 core 的个数（核数）</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">"cpu cores"</span> | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看逻辑 CPU 的个数（物理数 × 核心数）</span></span><br><span class="line">cat /proc/cpuinfo | grep <span class="string">"processor"</span> | wc -l</span><br></pre></td></tr></table></figure></p>
<p>Memory<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1606489-60b008a82eb16287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我机子的内存"></p>
<blockquote>
<p>从应用程序的角度来看，可用内存 = free + buffers + cached. 图中可用内存即为 13818M = 13G + 325M + 493M</p>
</blockquote>
<hr>
<p>（<em>未完待续</em> ……）</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu下彻底卸载MySQL]]></title>
      <url>/posts/fd2e73ac/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-ee85f904a2a2d603.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>真是被 Ubuntu 环境下的 MySQL 折磨的够呛。一次安装终身不改还好，卸载想重装其它版本？那各种报错可就来了，多数就是因为没卸干净。特写篇博客重点突出<strong>彻底</strong>二字！</p>
</blockquote>
<h2 id="开整"><a href="#开整" class="headerlink" title="开整"></a>开整</h2><p><code>sudo apt-get remove mysql</code> 就 OK 了？太年轻~</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dpkg --purge mysql-client-core-5.5</span><br><span class="line">sudo dpkg --purge mysql-client</span><br><span class="line">sudo dpkg --purge mysql-server-core-5.5</span><br><span class="line">sudo dpkg --purge mysql-common <span class="comment"># 依赖包放到最后清除</span></span><br><span class="line"><span class="comment"># sudo dpkg --purge mysql # 两次tab键是可以补全的命令的</span></span><br><span class="line"></span><br><span class="line">sudo apt-get --purge remove mysql-server-5.5</span><br><span class="line">sudo apt-get --purge remove mysql-client-5.5</span><br><span class="line">sudo apt-get --purge remove mysql-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL已经被卸载，依赖安装的软件就无用了（比如一些库）</span></span><br><span class="line"><span class="comment"># 该命令会自动清除这些无用依赖</span></span><br><span class="line">sudo apt-get autoremove </span><br><span class="line">sudo apt-get autoclean <span class="comment"># 删除无用的安装文件（.deb）</span></span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/mysql /etc/mysql ~/.mysql <span class="comment"># 删除残留的文件</span></span><br><span class="line">find / -name mysqld <span class="comment"># 找到残留的mysqld文件，然后删删删</span></span><br><span class="line"></span><br><span class="line">sudo deluser --remove-all-files mysql <span class="comment"># 删除mysql用户所拥有的全部文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重装之前</span></span><br><span class="line">sudo dpkg --configure -a <span class="comment"># 重新配置一下 dpkg</span></span><br><span class="line">sudo apt-get update <span class="comment"># 更新软件包信息列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否真的彻底了</span></span><br><span class="line"><span class="built_in">which</span> mysql <span class="comment"># 彻底的话会返回一个空结果。如果还有就把出来的那个结果再删了（不要怂，就是删！）</span></span><br><span class="line">mysql --version <span class="comment"># 彻底的话，会提示 mysql 尚未安装，请求安装的类似字样。如果不是就看看有没有漏掉什么</span></span><br></pre></td></tr></table></figure>
<p>我一开始真是乱删一通，恨不得把带 mysql 几个字的都给删了（但这种行为很不理智~请勿模仿）。<br><strong>这一套下来，还不 OK！就只能用那句老话了：重装系统吧~233</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由这个问题，引出了如何搜索文件或目录</span></span><br><span class="line">locate -e file_name</span><br><span class="line"><span class="comment"># 由于默认是模糊查询且列出查询结果的绝对路径，所以文件或目录是无所谓的;</span></span><br><span class="line"><span class="comment"># 该命令是建立一个索引库，无参数使用就是从库里搜索结果（与Win下的Everything类似）;</span></span><br><span class="line"><span class="comment"># 索引库默认每天更新一次，也可使用updatedb命令手动更新;</span></span><br><span class="line"><span class="comment"># 参数e代表仅列出当前系统中存在的结果，所以通常都会加上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 find</span></span><br><span class="line"><span class="comment"># 从根目录'/'开始，搜索出所有含有file_name的路径。 </span></span><br><span class="line">sudo find / -name file_name</span><br></pre></td></tr></table></figure>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>Linux 下不理解的操作最好不要直接搞（例如执行某些命令，或删除某些文件），不然就是自己给自己挖坑！不信你试试：<code>sudo rm -rf /*</code>  : ) 逃。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="http://blog.csdn.net/flydream0/article/details/8620396" target="_blank" rel="noopener">apt-get指令的autoclean,clean,autoremove的区别</a></li>
<li><a href="http://blog.csdn.net/sunjiajiang/article/details/7252593" target="_blank" rel="noopener">dpkg的用法</a></li>
</ul>
<hr>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>[1] <a href="http://askubuntu.com/questions/253023/unable-to-set-password-for-the-mysql-root-user" target="_blank" rel="noopener">Unable to set password for the mysql “root” user</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> MySQL卸载 </tag>
            
            <tag> 彻底卸载！ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux多版本JDK切换]]></title>
      <url>/posts/31b9e7c6/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-1c75a6e0d8e86fda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<p>一台机器上经常存在多个版本的JDK，如何方便的切换呢？Linux的<code>alternatives</code>命令完美地解决了这个问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">update-alternatives</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS</span></span><br><span class="line">alternatives</span><br></pre></td></tr></table></figure>
<p>不同Linux版本上命令名有所不同，但用法完全一样，下面以<strong>Ubuntu</strong>进行演示。</p>
<h3 id="注册JDK相关命令"><a href="#注册JDK相关命令" class="headerlink" title="注册JDK相关命令"></a>注册JDK相关命令</h3><p>机器上除了自带的OpenJDK，还有一个我自己下载的JDK1.8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update-alternatives --install &lt;link_path&gt; &lt;name&gt; &lt;command_path&gt; &lt;priority&gt;</span></span><br><span class="line"><span class="comment"># priority：数值越大优先级越高。当优先级为当前最大时，alternatives自动选择其为默认命令</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/java java /home/leo/jdk8/bin/java 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /home/leo/jdk8/bin/javac 1</span><br><span class="line">sudo update-alternatives --install /usr/bin/jar java /home/leo/jdk8/bin/jar 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一下 /usr/bin</span></span><br><span class="line">ls -al | grep java</span><br><span class="line"><span class="comment"># 效果如下</span></span><br><span class="line">lrwxrwxrwx  1 root root          22 11月 13  2015 java -&gt; /etc/alternatives/java</span><br><span class="line">lrwxrwxrwx  1 root root          23 11月 13  2015 javac -&gt; /etc/alternatives/javac</span><br></pre></td></tr></table></figure>
<h3 id="手动配置默认JDK相关命令"><a href="#手动配置默认JDK相关命令" class="headerlink" title="手动配置默认JDK相关命令"></a>手动配置默认JDK相关命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update-alternatives --config &lt;command_name&gt;</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"><span class="comment"># 出现选择界面，输入序号回车即可</span></span><br><span class="line">There are 2 choices <span class="keyword">for</span> the alternative java (providing /usr/bin/java).</span><br><span class="line"></span><br><span class="line">  Selection    Path                                            Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">  0            /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java   1071      auto mode</span><br><span class="line">* 1            /usr/lib/jvm/jdk8/bin/java                       1         manual mode</span><br><span class="line"></span><br><span class="line">Press enter to keep the current choice[*], or <span class="built_in">type</span> selection number: 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同上配置javac、jar命令即可</span></span><br></pre></td></tr></table></figure>
<h3 id="检查是否切换成功"><a href="#检查是否切换成功" class="headerlink" title="检查是否切换成功"></a>检查是否切换成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line"></span><br><span class="line">java version <span class="string">"1.8.0_161"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_161-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</span><br></pre></td></tr></table></figure>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><p>说白了<code>alternatives</code>就是创建了一个一个的软链接，并对软链接提供了方便的管理功能。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> JDK </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL问题集]]></title>
      <url>/posts/bb8b1640/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-15c05883073ef5a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<h3 id="ERROR-2002-HY000"><a href="#ERROR-2002-HY000" class="headerlink" title="ERROR 2002 (HY000)"></a>ERROR 2002 (HY000)</h3><p>环境：<strong>CentOS 7</strong>、<strong>MySQL 5.7</strong></p>
<p>MySQL服务启动成功，但是登录命令行客户端时却出现如下问题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql .sock&apos; (2)</span><br></pre></td></tr></table></figure>
<p>搜索了很多博客，解决手段很多，但都无济于事……</p>
<p>最后是<a href="https://blog.csdn.net/lmss82/article/details/4414178" target="_blank" rel="noopener">这篇文章</a>帮了大忙！</p>
<p>既然是关于<code>mysql.sock</code>这个东西的问题，那就：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先找一找 mysql.sock</span></span><br><span class="line">find / -name mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现它在这</span></span><br><span class="line">/var/lib/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误信息中，一直在找'/tmp/mysql.sock'?</span></span><br><span class="line"><span class="comment"># 那干脆直接链接过去</span></span><br><span class="line">ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock</span><br></pre></td></tr></table></figure>
<p>然后OK了……就这么简单。</p>
<p>推荐还是了解一下<code>mysql.sock</code>文件：<a href="https://blog.csdn.net/kerwin612/article/details/8568206" target="_blank" rel="noopener">mysql.sock详解</a>。</p>
<hr>
<p>（<em>未完待续……</em>）</p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MySQL事务隔离级别]]></title>
      <url>/posts/8f885523/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-1e9c390e4c7b4e2d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><ul>
<li><strong>原子性</strong>：指处于同一个事务中的多条语句是不可分割的。</li>
<li><strong>一致性</strong>：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。比如：转账—转账前两个账户余额之和为233￥，转账之后也应该是233￥。</li>
<li><strong>隔离性</strong>：指多线程环境下，一个线程中的事务不能被其他线程中的事务打扰</li>
<li><strong>持久性</strong>：事务一旦提交，就应该被永久保存起来。</li>
</ul>
<h2 id="事务的隔离性：隔离级别分类"><a href="#事务的隔离性：隔离级别分类" class="headerlink" title="事务的隔离性：隔离级别分类"></a>事务的隔离性：隔离级别分类</h2><p>如果不考虑事务的隔离性，则可能会出现以下问题：</p>
<ul>
<li><strong>脏读</strong>：指一个线程中的事务读取到了另外一个线程中<strong>未提交</strong>的数据。</li>
<li><strong>不可重复读</strong>：指一个线程中的事务读取到了另外一个线程中<strong>提交的update</strong>的数据。</li>
<li><strong>虚读</strong>：指一个线程中的事务读取到了另外一个线程中<strong>提交的insert</strong>的数据。</li>
</ul>
<p><strong>隔离级别</strong>：</p>
<ul>
<li><strong>1-READ UNCOMMITTED</strong>: 脏读、不可重复读、虚读都有可能发生。</li>
<li><strong>2-READ COMMITTED</strong>: 防止脏读的发生，不可重复读、虚读都有可能发生。</li>
<li><strong>4-REPEATABLE READ</strong>: 防止脏读、不可重复读的发生，虚读有可能发生。</li>
<li><strong>8-SERIALIZABLE</strong>: 防止脏读、不可重复读、虚读的发生。</li>
</ul>
<p>级别越高，数据越安全，相对就导致性能越低。</p>
<hr>
<h2 id="拿-MySQL-现身说法"><a href="#拿-MySQL-现身说法" class="headerlink" title="拿 MySQL 现身说法"></a>拿 MySQL 现身说法</h2><p>查看当前事务的隔离级别：<strong>SELECT @@tx_isolation;</strong></p>
<p>注意：<strong>更改事务的隔离级别，一定要在开启事务之前设置。</strong></p>
<p>更改事务：<strong>SET transaction isolation level 四个级别之一(单词);</strong></p>
<p>通过一个情景模拟来理解隔离级别：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 准备工作</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_account(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">    money <span class="built_in">float</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_account(<span class="keyword">id</span>,<span class="keyword">name</span>,money) <span class="keyword">values</span></span><br><span class="line">    (<span class="number">1</span>,<span class="string">'a'</span>,<span class="number">1000</span>),</span><br><span class="line">    (<span class="number">2</span>,<span class="string">'b'</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">set</span> transcation <span class="keyword">isolation</span> <span class="keyword">level</span> <span class="keyword">read</span> uncommited;</span><br><span class="line"><span class="comment">-- 可打开两个 CMD 窗口连接 MySQL 来模拟两位用户~</span></span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>线程1-自己</th>
<th>线程2-其他人</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1</td>
<td>start transacion;</td>
<td></td>
<td></td>
</tr>
<tr>
<td>t2</td>
<td>select * from t_account <br>where name=’a’</td>
<td></td>
<td>a查询账户：我有1000元</td>
</tr>
<tr>
<td>t3</td>
<td></td>
<td>start transaction;</td>
<td></td>
</tr>
<tr>
<td>t4</td>
<td></td>
<td>update t_account set money=money+100 <br>where name=’a’;</td>
<td>其他人：给a存100，逗逗他</td>
</tr>
<tr>
<td>t5</td>
<td>select * from t_account <br>where name=’a’</td>
<td></td>
<td>a再次查询账户，1100元（我靠，多了100块）！<br>读取到了另外一个<br>线程中未提交的数据，出现脏读</td>
</tr>
<tr>
<td>t6</td>
<td></td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>t7</td>
<td>select * from t_account <br>where name=’a’</td>
<td></td>
<td>a又查询账户，发现还是1100元（踩到狗屎啦？）。<br>前后读到的数据不一致，<br>读到了另外一个线程中提交的 update 数据，<br>出现可重复读</td>
</tr>
<tr>
<td>t8</td>
<td></td>
<td>insert into t_account <br>values(2,’蛤蛤蛤’,233);</td>
<td></td>
</tr>
<tr>
<td>t9</td>
<td>select * from t_account;</td>
<td></td>
<td>还是让工作人员来确认下吧。<br>一查总用户，我凑又多了一个人叫“蛤蛤蛤”！<br>读到了另外一个线程中提交的 insert 数据，出现虚读</td>
</tr>
<tr>
<td>t10</td>
<td>commit;</td>
<td></td>
<td>工作人员提交事务，两人一脸懵逼……</td>
</tr>
</tbody>
</table>
<h2 id="JDBC-中控制事务的隔离级别："><a href="#JDBC-中控制事务的隔离级别：" class="headerlink" title="JDBC 中控制事务的隔离级别："></a>JDBC 中控制事务的隔离级别：</h2><p>前提：在开启事务之前设置隔离级别。</p>
<p>通过<code>Connection</code>中的整型常量代表不同的级别：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1606489-56d81fd181aec8e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实际就是一个整数常量"></p>
<p>设置事务的隔离级别：<strong>Connection：void setTransactionIsolation(int level);</strong></p>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库事务 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hive踩坑日记]]></title>
      <url>/posts/72767b4e/</url>
      <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1606489-79f2ba596d334c26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<p>Hadoop 家族动物园里属这个<strong>蜜蜂</strong>配置过程中坑最多，得动动笔了。</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Hive 是个啥？移步 <a href="http://baike.baidu.com/item/hive/67986" target="_blank" rel="noopener">传送门</a>。</p>
</blockquote>
<h2 id="踩坑环境"><a href="#踩坑环境" class="headerlink" title="踩坑环境"></a>踩坑环境</h2><table>
<thead>
<tr>
<th>软件</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚拟机系统</td>
<td>Ubuntu Server 16.04.2</td>
</tr>
<tr>
<td>Hadoop</td>
<td>Hadoop 2.6.0</td>
</tr>
<tr>
<td>MySQL</td>
<td>MySQL 5.7</td>
</tr>
</tbody>
</table>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>MySQL 扮演的角色是存储 Hive 库的元数据，当然还可配置其它的方式存储，这里不多说。Hive 前期配置多数坑都在 MySQL 这，所以把 MySQL 整好会顺利许多。</p>
<p><strong>1. 配置远程访问</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure></p>
<p>将 <code>bind-address=127.0.0.1</code> 改为 自己机器的 IP。</p>
<p><strong>特别说明</strong>：Ubuntu 新版的 MySQL 中 <strong>my.cnf</strong> 里不直接显示属性了，默认属性值被移到 <code>/etc/mysql/conf.d/mysql.cnf</code> 和 <code>/etc/mysql/mysql.conf.d/mysql.cnf</code> 里。所以可参考 <code>/etc/mysql/mysql.conf.d/mysql.cnf</code> 文件来进行配置。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 /etc/mysql/my.cnf 文件末尾配置新值以覆盖默认值</span></span><br><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">bind</span>-address=your_machine_ip</span><br></pre></td></tr></table></figure></p>
<p><strong>[mysqld]</strong> 是属性组，不加不符合语法，会导致 MySQL 服务无法启动。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前启动的 MySQL 的属性值</span></span><br><span class="line">$ mysql --<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2. 新建 hive 用户来操作 MySQL</strong><br>为 Hive 新建一个 MySQL 用户来专门操作 Hive 的元数据库。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br><span class="line"></span><br><span class="line">mysql&gt; grant all privileges on *.* to hive@<span class="string">"Master"</span> identified by <span class="string">"hive"</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></p>
<p>最好是仅赋予 Hive 用户操作元数据库的权限，我为了操作方便就权限全给了。”Master” 是我配置的机器主机名，用于 hadoop 等集群搭建的。</p>
<p><strong>3. 准备好 JDBC 驱动包</strong><br>将 jdbc 驱动包放到 <code>${HIVE_HOME}/lib/</code> 下，尽量用高本版驱动，驱动版本不对也会导致启动 Hive 时出错，这里我是选择了：<a href="https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.42.tar.gz" target="_blank" rel="noopener">mysql-connector-java-5.1.40-bin</a></p>
<h2 id="坑来"><a href="#坑来" class="headerlink" title="坑来~"></a>坑来~</h2><p><strong>1. hive-site.xml 中 MySQL jdbc 连接地址出错</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 异常信息</span></span><br><span class="line">The reference to entity <span class="string">"XXX"</span> must end with the <span class="string">';'</span> delimiter</span><br></pre></td></tr></table></figure></p>
<p>我当时写的是：<br><code>jdbc:mysql://Master:3306/metastore?createDatabaseIfNotExist=true&amp;useSSL=false</code>，后来在这篇<a href="http://boyadn.blog.163.com/blog/static/74230736201012292739317/" target="_blank" rel="noopener">博客</a>中得知”<strong>&amp;</strong>“这类特殊字符在 xml 文件中需要转义，写成”<strong>&amp;amp;</strong>“就OK了。</p>
<p>在 xml 文件中还有几个常见的字符需要转义替换：</p>
<table>
<thead>
<tr>
<th>原字符</th>
<th>转义字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>&amp;amp;</td>
</tr>
<tr>
<td>&lt;</td>
<td>&amp;lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt;</td>
</tr>
<tr>
<td>“</td>
<td>&amp;quot;</td>
</tr>
<tr>
<td>‘</td>
<td>&amp;apos;</td>
</tr>
</tbody>
</table>
<p><strong>2. hive 命令进入 Hive CLI(command line interface) 异常</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ hive</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException: java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</span><br><span class="line">        at org.apache.hadoop.hive.ql.session.SessionState.start(SessionState.java:<span class="number">444</span>)</span><br><span class="line">        at org.apache.hadoop.hive.cli.CliDriver.run(CliDriver.java:<span class="number">672</span>)</span><br><span class="line">        at org.apache.hadoop.hive.cli.CliDriver.main(CliDriver.java:<span class="number">616</span>)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">39</span>)</span><br></pre></td></tr></table></figure></p>
<p>原因：没有正常启动 Hive 的 <strong>Metastore Server</strong> 服务。<br>解决方法：后台启动 Hive 的 Metastore Server服务：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hive --service metastore &amp;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. hiveserver 启动异常</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ hive --service hiveserver &amp;</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassNotFoundException: org.apache.hadoop.hive.service.HiveServer</span><br><span class="line">        at java.net.URLClassLoader$<span class="number">1</span>.run(URLClassLoader.java:<span class="number">366</span>)</span><br><span class="line">        at java.net.URLClassLoader$<span class="number">1</span>.run(URLClassLoader.java:<span class="number">355</span>)</span><br><span class="line">        at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">354</span>)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">425</span>)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">358</span>)</span><br></pre></td></tr></table></figure></p>
<p>进入 Hive CLI 前需要先启两个服务一个是 (1) 中说的 <strong>metastore server</strong>，还有一个 <strong>hiveserver</strong> 。</p>
<p>这里的异常解决方法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类是 hiveserver2 ... 额</span></span><br><span class="line">$ hive --service hiveserver2 &amp;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. hive 命令进入 Hive CLI 异常</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ hive</span><br><span class="line"></span><br><span class="line">[ERROR] Terminal initialization failed; falling back to unsupported</span><br><span class="line">java.lang.IncompatibleClassChangeError: Found <span class="class"><span class="keyword">class</span> <span class="title">jline</span>.<span class="title">Terminal</span>, <span class="title">but</span> <span class="title">interface</span> <span class="title">was</span> <span class="title">expected</span></span></span><br><span class="line">        at jline.TerminalFactory.create(TerminalFactory.java:101)</span><br><span class="line">        at jline.TerminalFactory.get(TerminalFactory.java:<span class="number">158</span>)</span><br><span class="line">        at jline.console.ConsoleReader.&lt;init&gt;(ConsoleReader.java:<span class="number">229</span>)</span><br><span class="line">        at jline.console.ConsoleReader.&lt;init&gt;(ConsoleReader.java:<span class="number">221</span>)</span><br><span class="line">        at jline.console.ConsoleReader.&lt;init&gt;(ConsoleReader.java:<span class="number">209</span>)</span><br><span class="line">        at org.apache.hadoop.hive.cli.CliDriver.getConsoleReader(CliDriver.java:<span class="number">773</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个异常原因在 Hive 官方文档里有说：</p>
<blockquote>
<p>Hive has upgraded to Jline2 but jline 0.9x exists in the Hadoop lib.</p>
</blockquote>
<p>解决方法：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除老版本的 jline.jar</span></span><br><span class="line">$ rm <span class="variable">$&#123;HADOOP_HOME&#125;</span>/share/hadoop/yarn/lib/jline-0.9.94.jar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝新版本 jline.jar 到相应的 hadoop lib 目录下</span></span><br><span class="line">$ cp <span class="variable">$&#123;HIVE_HOME&#125;</span>/lib/jline-2.12.jar <span class="variable">$&#123;HADOOP_HOME&#125;</span>/share/hadoop/yarn/lib/</span><br></pre></td></tr></table></figure></p>
<hr>
<p>（<em>继续踩坑中……</em>）</p>
<hr>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="http://boyadn.blog.163.com/blog/static/74230736201012292739317/" target="_blank" rel="noopener">The reference to entity “characterEncoding” must end with the ‘;’ delimiter</a> <br><br>[2] <a href="http://blog.csdn.net/freedomboy319/article/details/44828337" target="_blank" rel="noopener">Hive常见问题汇总</a> <br><br>[3] <a href="https://stackoverflow.com/questions/28997441/hive-startup-error-terminal-initialization-failed-falling-back-to-unsupporte" target="_blank" rel="noopener">hive startup -[ERROR] Terminal initialization failed; falling back to unsupported</a></p>
]]></content>
      
        <categories>
            
            <category> 大数据 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Git命令手册]]></title>
      <url>/posts/52a75fbe/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1606489-599a5f95e2e6398e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git is great!"></p>
<a id="more"></a>
<h2 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新建一个本地仓库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 GitHub 上克隆一个仓库到本地（可理解为下载）</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/xxx/yyy.git</span><br></pre></td></tr></table></figure>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示工作目录下被修改的文件信息</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪文件的变化（显示文件详细的修改信息）</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两次提交的文件变化</span></span><br><span class="line">$ git diff &lt;commit_id_1&gt; &lt;commit_id_2&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前所有的修改到下一次提交</span></span><br><span class="line">$ git add -A</span><br><span class="line"><span class="comment"># 添加某个或部分修改到下一次提交</span></span><br><span class="line">$ git add &lt;change&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交之前的修改并附加一条说明信息</span></span><br><span class="line">$ git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure>
<h2 id="历史提交"><a href="#历史提交" class="headerlink" title="历史提交"></a>历史提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示所有的提交信息，从最新一次提交开始显示</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示更详细的提交信息，包括每次提交的文件修改情况</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定提交信息的显示条数，从最新一次提交开始显示</span></span><br><span class="line">$ git <span class="built_in">log</span> -n &lt;display_num&gt;</span><br></pre></td></tr></table></figure>
<h2 id="分支和标签"><a href="#分支和标签" class="headerlink" title="分支和标签"></a>分支和标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示存在的所有分支</span></span><br><span class="line">$ git branch -av</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前分支的基础上新建一条分支</span></span><br><span class="line">$ git branch &lt;new_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一条分支</span></span><br><span class="line">$ git branch -d &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用一个标签标记当前提交（可用于定义版本：v1.0、v1.1）</span></span><br><span class="line">$ git tag &lt;tag_name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="更新和发布"><a href="#更新和发布" class="headerlink" title="更新和发布"></a>更新和发布</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前所有配置的远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示一个远程仓库的信息</span></span><br><span class="line">$ git remote show &lt;remote_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加一个新的远程仓库，并起个名</span></span><br><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载远程仓库所有的修改，且不和当前分支进行合并</span></span><br><span class="line">$ git fetch &lt;remote&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载修改并和指定的分支进行合并</span></span><br><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布本地的修改到远程仓库</span></span><br><span class="line">$ git push &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地新分支推送到远程</span></span><br><span class="line">$ git push origin &lt;branch&gt;:&lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin :&lt;remote_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布你的“版本”（就是标签）</span></span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure>
<h2 id="合体"><a href="#合体" class="headerlink" title="合体"></a>合体</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 合并 &lt;branch&gt; 到当前分支</span></span><br><span class="line">$ git merge &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置合并工具解决冲突问题</span></span><br><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure>
<h2 id="反悔啦"><a href="#反悔啦" class="headerlink" title="反悔啦"></a>反悔啦</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有的 HEAD ID</span></span><br><span class="line">$ git reflog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤消当前工作目录下所有的本地修改</span></span><br><span class="line">$ git reset --hard &lt;HEAD_ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤消特定文件的本地修改</span></span><br><span class="line">$ git checkout &lt;HEAD_ID&gt; &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复到指定提交点</span></span><br><span class="line">$ git reset --hard &lt;commit_id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留新的提交，回退到指定提交点</span></span><br><span class="line">$ git checkout &lt;commit_id&gt;</span><br><span class="line">$ git checkout -b &lt;new_branch&gt;</span><br></pre></td></tr></table></figure>
<h2 id="HELP-君"><a href="#HELP-君" class="headerlink" title="HELP 君"></a>HELP 君</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git 基本命令的帮助信息</span></span><br><span class="line">$ git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某条命令的帮助信息</span></span><br><span class="line">$ git &lt;<span class="built_in">command</span>&gt; -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开某条命令的详细帮助手册（网页）</span></span><br><span class="line">$ git <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p>（<em>未完待续……</em>）</p>
]]></content>
      
        <categories>
            
            <category> 备忘录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[软件收藏清单]]></title>
      <url>/posts/879b9f5e/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1606489-0e6ce883c36509da.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<a id="more"></a>
<p>整理一下自己觉得好用的软件，避免再次发生<strong>想不起名字，狂搜半天的惨痛事件</strong>。</p>
<hr>
<h2 id="日常"><a href="#日常" class="headerlink" title="日常"></a>日常</h2><ul>
<li><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul>
<li><a href="http://www.google.cn/intl/zh-CN/chrome/browser/desktop/index.html" target="_blank" rel="noopener">Google Chrome</a></li>
<li><a href="http://se.360.cn/" target="_blank" rel="noopener">360 安全浏览器</a></li>
<li><a href="https://www.torproject.org/projects/torbrowser.html.en" target="_blank" rel="noopener">Tor Browser</a>：Access to dark net</li>
</ul>
</li>
<li><h3 id="安全-管理"><a href="#安全-管理" class="headerlink" title="安全 / 管理"></a>安全 / 管理</h3><ul>
<li><a href="http://www.huorong.cn/" target="_blank" rel="noopener">火绒</a></li>
<li><a href="https://www.piriform.com/CCLEANER" target="_blank" rel="noopener">CCleaner</a>：世界上最受欢迎的 PC 清理和优化工具</li>
</ul>
</li>
<li><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><ul>
<li><a href="http://music.163.com/" target="_blank" rel="noopener">网易云音乐</a></li>
</ul>
</li>
<li><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><ul>
<li><a href="http://potplayer.daum.net/?lang=zh_CN" target="_blank" rel="noopener">Potplayer</a></li>
<li><a href="https://ocam.en.softonic.com/" target="_blank" rel="noopener">oCam</a>：小巧强大的录屏软件</li>
</ul>
</li>
<li><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><a href="https://www.foxitsoftware.cn/" target="_blank" rel="noopener">福昕阅读器</a>：PDF</li>
<li><a href="https://www.sumatrapdfreader.org/free-pdf-reader.html" target="_blank" rel="noopener">Sumatra PDF</a>：开源</li>
<li><a href="https://www.jisupdf.com/?ac=index" target="_blank" rel="noopener">极速PDF阅读器</a></li>
<li><a href="https://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a>：电子书管理</li>
<li><a href="http://www.wps.cn/" target="_blank" rel="noopener">WPS</a>：办公套装</li>
</ul>
</li>
<li><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a>：不止是截图</li>
<li><a href="http://mydown.yesky.com/pcsoft/265607.html" target="_blank" rel="noopener">FastStone Screen Capture</a>：前端开发必备</li>
<li><a href="http://www.ghisler.com/" target="_blank" rel="noopener">Total Commander</a>：碉堡的文件管理软件</li>
<li><a href="http://yasuo.360.cn/" target="_blank" rel="noopener">360 压缩</a></li>
<li><a href="http://www.360.cn/qudongdashi/" target="_blank" rel="noopener">360 驱动大师</a></li>
<li><a href="http://www.voidtools.com/" target="_blank" rel="noopener">Everything</a>：文件查找神器</li>
<li><a href="http://www.getwox.com/" target="_blank" rel="noopener">Wox</a>：快速启动</li>
<li><a href="https://www.teamviewer.com/zhcn/" target="_blank" rel="noopener">TeamViewer</a></li>
<li><a href="http://wifi.liebao.cn/" target="_blank" rel="noopener">猎豹 WiFi</a></li>
<li><a href="http://www.pcfreetime.com/" target="_blank" rel="noopener">格式工厂</a></li>
<li><a href="https://www.xp510.com/xiazai/Application/other/33649.html" target="_blank" rel="noopener">Simple Mind</a>：简洁的思维导图</li>
<li><a href="">KMSAuto-Net</a>：微软软件激活工具（主要是 Office）</li>
<li><a href="http://www.1checker.com/Products/DownLoad" target="_blank" rel="noopener">1Checker</a>：英文校对 </li>
<li><a href="http://www.flvcd.com/index.htm" target="_blank" rel="noopener">硕鼠下载器</a>：视频网站解析及视频下载</li>
</ul>
</li>
</ul>
<h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><ul>
<li><h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul>
<li><a href="http://www.eclipse.org/" target="_blank" rel="noopener">Eclipse</a></li>
<li><a href="https://www.continuum.io/anaconda-overview" target="_blank" rel="noopener">Anaconda</a></li>
<li><a href="https://www.jetbrains.com/" target="_blank" rel="noopener">Jetbrains 全家桶</a>（学生邮箱免费）</li>
<li><a href="https://www.rstudio.com/" target="_blank" rel="noopener">RStudio</a></li>
</ul>
</li>
<li><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li>
</ul>
</li>
<li><h3 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h3><ul>
<li><a href="https://www.gnu.org/software/octave/" target="_blank" rel="noopener">Octave</a></li>
</ul>
</li>
<li><h3 id="Database-GUI-Tool"><a href="#Database-GUI-Tool" class="headerlink" title="Database GUI Tool"></a>Database GUI Tool</h3><ul>
<li><a href="http://mydown.yesky.com/pcsoft/33369680.html" target="_blank" rel="noopener">SQLyog</a>：MySQL</li>
<li><a href="https://mongobooster.com/home" target="_blank" rel="noopener">MongoBooster</a>：MongoDB</li>
<li><a href="http://www.liangchan.net/liangchan/4785.html" target="_blank" rel="noopener">Navicat Premium</a>：多支持</li>
</ul>
</li>
<li><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul>
<li><a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a>：推荐！</li>
<li><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>：（插件列表）<ul>
<li>Plugin Manager</li>
<li>Compare</li>
<li>HEX-Editor</li>
<li>HTML Tag</li>
<li>JSON Viewer</li>
<li>NppFTP</li>
</ul>
</li>
<li><a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>：所见即所得的 Markdown</li>
<li><a href="https://zh-cn.emeditor.com/" target="_blank" rel="noopener">EmEditor</a>：超大文本编辑，据说上限 <strong>248GB</strong></li>
<li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a>：（插件列表）<ul>
<li><a href="https://packagecontrol.io/" target="_blank" rel="noopener">Package Control</a></li>
<li><a href="http://damnwidget.github.io/anaconda/" target="_blank" rel="noopener">Anaconda</a>：ST 华丽变身为 Python IDE</li>
<li><a href="https://github.com/sindresorhus/sublime-autoprefixer" target="_blank" rel="noopener">Autoprefixer</a>：CSS3 兼容前缀自动补全</li>
<li><a href="https://www.emmet.io/" target="_blank" rel="noopener">Emmet</a></li>
<li>HTML-CSS-JS Prettify</li>
<li>jQuery</li>
<li>Markdown Preview</li>
<li>Pretty JSON</li>
<li>requirementstxt：Py requirements 文件高亮</li>
<li>SideBarEnhancements：ST sidebar 终极增强</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><ul>
<li><a href="ed2k://|file|cn_visio_professional_2016_x86_x64_dvd_6970929.iso|2588262400|52A997F3AF4E40B896C8E4677CF10E90|/" target="_blank" rel="noopener">Microsoft Visio</a>：首选！</li>
<li><a href="https://chrome.google.com/webstore/detail/bhmicilclplefnflapjmnngmkkkkpfad?utm_source=chrome-ntp-launcher" target="_blank" rel="noopener">Gliffy Diagrams</a>：Chrome plugin，可独立运行</li>
<li><a href="http://dia-installer.de/" target="_blank" rel="noopener">DIA Diagram Editor</a></li>
<li><a href="https://www.edrawsoft.com/EDrawMax.php" target="_blank" rel="noopener">Edraw Max</a>：图略丑</li>
</ul>
</li>
<li><h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a href="http://cmder.net/" target="_blank" rel="noopener">Cmder</a>：Better cmd</li>
<li><a href="http://www.netsarang.com/products/xsh_overview.html" target="_blank" rel="noopener">Xshell</a></li>
<li><a href="http://www.uvviewsoft.com/logviewer/" target="_blank" rel="noopener">LogViewer</a>：大文本查看，秒开</li>
<li><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">Shadowsocks</a>：SSR不在更新，SS仍在</li>
<li><a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a></li>
<li><a href="http://cygwin.com/" target="_blank" rel="noopener">Cygwin</a></li>
<li><a href="https://my.worktile.com/" target="_blank" rel="noopener">Worktile</a>：任务管理平台</li>
<li><a href="https://www.teambition.com" target="_blank" rel="noopener">Teambition</a>：任务管理平台</li>
<li><a href="http://www.wampserver.com/en/" target="_blank" rel="noopener">WAMP</a></li>
</ul>
</li>
</ul>
<hr>
<p><em>待续 . . .</em></p>
]]></content>
      
        <categories>
            
            <category> 备忘录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> software </tag>
            
            <tag> 收藏 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
